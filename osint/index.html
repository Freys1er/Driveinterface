<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Google Contacts Network Graph</title>
    <style>
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --accent-color: #0f0;
            --panel-bg: rgba(30, 30, 30, 0.9);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow: hidden;
            /* Prevent scroll on mobile */
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* --- UI Overlay --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        header {
            padding: 10px 20px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--accent-color);
            font-family: 'Courier New', monospace;
        }

        .btn {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #555;
        }

        .btn-primary {
            background: #006400;
            border-color: #008000;
        }

        /* --- Controls Bar --- */
        #controls-bar {
            padding: 15px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
            background: linear-gradient(0deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
        }

        input[type="text"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #222;
            color: white;
        }

        /* --- Canvas --- */
        #network-container {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            /* Critical for mobile drag */
            cursor: grab;
        }

        canvas.grabbing {
            cursor: grabbing;
        }

        /* --- Detail Modal --- */
        #detail-modal {
            position: absolute;
            bottom: -300px;
            /* Hidden by default */
            left: 0;
            width: 100%;
            background: #1e1e1e;
            border-top: 2px solid var(--accent-color);
            padding: 20px;
            box-sizing: border-box;
            transition: bottom 0.3s ease-out;
            pointer-events: auto;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
        }

        #detail-modal.active {
            bottom: 0;
        }

        .modal-content {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .modal-img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--accent-color);
        }

        .modal-info h2 {
            margin: 0 0 5px 0;
            font-size: 1.2rem;
        }

        .modal-info p {
            margin: 2px 0;
            font-size: 0.9rem;
            color: #aaa;
        }

        .close-modal {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 1.5rem;
            cursor: pointer;
        }

        /* --- Loading / Auth Screen --- */
        #auth-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #121212;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
    </style>
</head>

<body>

    <!-- Auth / Loading Overlay -->
    <div id="auth-screen">
        <h1 style="margin-bottom: 20px; font-size: 2rem;">CONTACT OSINT</h1>
        <p id="status-text">Initializing Google API...</p>
        <button id="auth-btn" class="btn btn-primary" style="display:none; margin-top: 20px;">Authorize Google
            Contacts</button>
    </div>

    <!-- Main Application -->
    <div id="ui-layer" style="display:none;">
        <header>
            <h1>NETWORK</h1>
            <div style="display:flex; gap:10px;">
                <button id="fullscreen-btn" class="btn">â›¶</button>
                <button id="signout-btn" class="btn">Logout</button>
            </div>
        </header>

        <div id="detail-modal">
            <span class="close-modal">&times;</span>
            <div class="modal-content">
                <img id="modal-img" src="" class="modal-img" alt="">
                <div class="modal-info">
                    <h2 id="modal-name">Name</h2>
                    <p id="modal-org">Organization</p>
                    <p id="modal-email">Email</p>
                </div>
            </div>
        </div>

        <div id="controls-bar">
            <button id="pause-button" class="btn">Pause</button>
            <input type="text" id="find-input" placeholder="Search name...">
            <button id="find-button" class="btn">Find</button>
            <button id="reset-cam-button" class="btn">Reset View</button>
        </div>
    </div>

    <div id="network-container">
        <canvas id="network-canvas"></canvas>
    </div>

    <!-- Google API Script -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>

    <script>
        // ================= CONFIGURATION =================
        // TODO: Replace with your own Client ID from Google Cloud Console
        const CLIENT_ID = '490934668566-dpcfvk9p5kfpk44ko8v1gl3d5i9f83qr.apps.googleusercontent.com';
        const API_KEY = ''; // Optional if using implicit flow with only client ID, but recommended for some quotas.
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/people/v1/rest';
        const SCOPES = 'https://www.googleapis.com/auth/contacts.readonly';

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let allContacts = [];

        // ================= AUTHENTICATION =================

        function gapiLoaded() {
            gapi.load('client', async () => {
                await gapi.client.init({
                    discoveryDocs: [DISCOVERY_DOC],
                });
                gapiInited = true;
                checkAuth();
            });
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '', // defined later
            });
            gisInited = true;
            checkAuth();
        }

        function checkAuth() {
            if (gapiInited && gisInited) {
                const token = localStorage.getItem('google_access_token');
                if (token) {
                    // Check if token is valid by trying a simple call
                    gapi.client.setToken({ access_token: token });
                    loadGoogleContacts();
                } else {
                    document.getElementById('status-text').textContent = "Please sign in to view your network.";
                    document.getElementById('auth-btn').style.display = 'block';
                }
            }
        }

        document.getElementById('auth-btn').addEventListener('click', () => {
            tokenClient.callback = async (resp) => {
                if (resp.error) throw resp;
                localStorage.setItem('google_access_token', resp.access_token);
                loadGoogleContacts();
            };
            tokenClient.requestAccessToken({ prompt: 'consent' });
        });

        document.getElementById('signout-btn').addEventListener('click', () => {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                localStorage.removeItem('google_access_token');
                location.reload();
            }
        });

        // ================= DATA FETCHING & PROCESSING =================

        async function loadGoogleContacts() {
            document.getElementById('auth-btn').style.display = 'none';
            document.getElementById('status-text').textContent = "Fetching contacts...";

            try {
                // Added 'relations' to the request fields
                const response = await gapi.client.people.people.connections.list({
                    'resourceName': 'people/me',
                    'pageSize': 1000,
                    'personFields': 'names,photos,emailAddresses,organizations,relations'
                });

                const connections = response.result.connections || [];
                document.getElementById('status-text').textContent = `Processing ${connections.length} contacts...`;

                processContacts(connections);

                document.getElementById('auth-screen').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'flex';

            } catch (err) {
                console.error("API Error:", err);
                document.getElementById('status-text').textContent = "Error fetching contacts. See console.";
                // Only clear token if it's a 401/403 error to avoid loop
                if (err.status === 401 || err.status === 403) {
                    localStorage.removeItem('google_access_token');
                    document.getElementById('auth-btn').style.display = 'block';
                }
            }
        }

        function processContacts(googleData) {
            allContacts = googleData.map(person => {
                const name = person.names ? person.names[0].displayName : 'Unknown';
                const photo = person.photos ? person.photos[0].url : null;
                const email = person.emailAddresses ? person.emailAddresses[0].value : 'No Email';
                const org = person.organizations ? person.organizations[0].name : null;
                const id = person.resourceName;

                // Extract relations: Array of { person: "Name", type: "Friend/Partner/etc" }
                const relations = person.relations ? person.relations.map(r => ({
                    targetName: r.person,
                    type: r.type // This is the label (Friend, Partner, or Custom)
                })) : [];

                return { id, name, photo, email, org, relations };
            });

            initializeNetworkGraph(allContacts);
        }

        // ================= GRAPH LOGIC =================

        function initializeNetworkGraph(contacts) {
            const canvas = document.getElementById('network-canvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('network-container');

            // 1. Create Nodes and a Lookup Map for Name -> ID
            const nameToIdMap = new Map();

            const nodes = contacts.map(c => {
                if (c.name) nameToIdMap.set(c.name.toLowerCase().trim(), c.id);

                return {
                    id: c.id,
                    data: c,
                    x: (Math.random() - 0.5) * 800,
                    y: (Math.random() - 0.5) * 800,
                    vx: 0, vy: 0,
                    img: null,
                    isLoaded: false
                };
            });

            // Preload Images
            nodes.forEach(node => {
                if (node.data.photo) {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = node.data.photo;
                    img.onload = () => { node.img = img; node.isLoaded = true; };
                }
            });

            // 2. Create Edges
            const edges = [];

            const edgeExists = (a, b) => edges.some(e =>
                (e.source === a && e.target === b) || (e.source === b && e.target === a)
            );

            contacts.forEach(sourceContact => {
                if (!sourceContact.relations) return;

                sourceContact.relations.forEach(rel => {
                    const targetNameClean = rel.targetName.toLowerCase().trim();
                    const targetId = nameToIdMap.get(targetNameClean);

                    if (targetId && targetId !== sourceContact.id) {
                        if (!edgeExists(sourceContact.id, targetId)) {

                            // --- UPDATED LOGIC START ---
                            let strength = 0.05;
                            let length = 150;
                            const type = rel.type.toLowerCase();

                            // Store raw value for coloring later
                            let rawValue = 0;

                            const numVal = parseInt(type);

                            if (!isNaN(numVal)) {
                                rawValue = numVal;
                                const magnitude = Math.abs(numVal); // Use absolute value for distance

                                // 1. DISTANCE CALCULATION
                                // 100 or -100 = Very Close (Length 50)
                                // 0 = Far (Length 300)
                                length = 300 - (magnitude * 2.5);
                                if (length < 50) length = 50; // Clamp minimum distance

                                // 2. STRENGTH CALCULATION
                                // Higher magnitude = Stronger physics pull
                                strength = 0.05 + (magnitude / 500);
                            }
                            // Handle text keywords (fallback for non-numeric)
                            else {
                                if (['spouse', 'partner', 'husband', 'wife', 'girlfriend', 'boyfriend'].includes(type)) {
                                    strength = 0.3; length = 50; rawValue = 100;
                                } else if (['friend', 'brother', 'sister', 'parent'].includes(type)) {
                                    strength = 0.1; length = 100; rawValue = 50;
                                } else if (['enemy', 'rival', 'ex'].includes(type)) {
                                    strength = 0.1; length = 100; rawValue = -50; // Negative keyword
                                }
                            }
                            // --- UPDATED LOGIC END ---

                            edges.push({
                                source: sourceContact.id,
                                target: targetId,
                                label: rel.type,
                                strength: strength,
                                length: length,
                                val: rawValue // Store this for the draw function
                            });
                        }
                    }
                });
            });

            // --- Physics State ---
            let scale = 0.8;
            let viewOffset = { x: 0, y: 0 };
            let isPaused = false;
            let draggedNode = null;
            let isPanning = false;
            let lastPos = { x: 0, y: 0 };
            const NODE_RADIUS = 25;

            // --- Interaction Handlers ---
            function getPointerPos(e) {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left - rect.width / 2 - viewOffset.x) / scale,
                    y: (clientY - rect.top - rect.height / 2 - viewOffset.y) / scale,
                    rawX: clientX, rawY: clientY
                };
            }

            function onStart(e) {
                if (e.target !== canvas) return;
                const pos = getPointerPos(e);
                const clickedNode = nodes.find(n => {
                    const dx = n.x - pos.x;
                    const dy = n.y - pos.y;
                    return (dx * dx + dy * dy) < (NODE_RADIUS * NODE_RADIUS);
                });
                if (clickedNode) {
                    draggedNode = clickedNode;
                    draggedNode.vx = 0; draggedNode.vy = 0;
                } else {
                    isPanning = true;
                    lastPos = { x: pos.rawX, y: pos.rawY };
                    canvas.classList.add('grabbing');
                }
            }

            function onMove(e) {
                if (draggedNode) {
                    const pos = getPointerPos(e);
                    draggedNode.x = pos.x; draggedNode.y = pos.y;
                    e.preventDefault();
                } else if (isPanning) {
                    const cx = e.touches ? e.touches[0].clientX : e.clientX;
                    const cy = e.touches ? e.touches[0].clientY : e.clientY;
                    viewOffset.x += cx - lastPos.x;
                    viewOffset.y += cy - lastPos.y;
                    lastPos = { x: cx, y: cy };
                    e.preventDefault();
                }
            }

            function onEnd(e) {
                if (draggedNode && Math.abs(draggedNode.vx) < 0.1) {
                    if (typeof showModal === 'function') showModal(draggedNode);
                }
                draggedNode = null;
                isPanning = false;
                canvas.classList.remove('grabbing');
            }

            function onWheel(e) {
                e.preventDefault();
                scale += e.deltaY * -0.001;
                scale = Math.min(Math.max(.1, scale), 5);
            }

            canvas.addEventListener('mousedown', onStart);
            canvas.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onEnd);
            canvas.addEventListener('touchstart', onStart, { passive: false });
            canvas.addEventListener('touchmove', onMove, { passive: false });
            window.addEventListener('touchend', onEnd);
            canvas.addEventListener('wheel', onWheel, { passive: false });

            // --- Controls ---
            const btnPause = document.getElementById('pause-button');
            if (btnPause) btnPause.onclick = function () { isPaused = !isPaused; this.innerText = isPaused ? "Play" : "Pause"; };
            const btnReset = document.getElementById('reset-cam-button');
            if (btnReset) btnReset.onclick = function () { viewOffset = { x: 0, y: 0 }; scale = 0.8; };
            const btnFind = document.getElementById('find-button');
            if (btnFind) btnFind.onclick = findNode;

            function findNode() {
                const input = document.getElementById('find-input');
                if (!input) return;
                const node = nodes.find(n => n.data.name.toLowerCase().includes(input.value.toLowerCase()));
                if (node) {
                    viewOffset.x = -node.x * scale; viewOffset.y = -node.y * scale;
                    node.highlight = Date.now() + 2000;
                }
            }

            // --- Loop ---
            function resize() { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            window.addEventListener('resize', resize);
            resize();

            function update() {
                if (isPaused) return;
                const repulsion = 2000;

                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const a = nodes[i], b = nodes[j];
                        const dx = b.x - a.x, dy = b.y - a.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        if (dist > 800) continue;
                        const force = repulsion / (dist * dist);
                        a.vx -= (dx / dist) * force; a.vy -= (dy / dist) * force;
                        b.vx += (dx / dist) * force; b.vy += (dy / dist) * force;
                    }
                }

                edges.forEach(e => {
                    const a = nodes.find(n => n.id === e.source);
                    const b = nodes.find(n => n.id === e.target);
                    if (!a || !b) return;
                    const dx = b.x - a.x, dy = b.y - a.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = (dist - e.length) * e.strength;
                    a.vx += (dx / dist) * force; a.vy += (dy / dist) * force;
                    b.vx -= (dx / dist) * force; b.vy -= (dy / dist) * force;
                });

                nodes.forEach(n => {
                    n.vx -= n.x * 0.0002; n.vy -= n.y * 0.0002;
                    if (n !== draggedNode) {
                        n.x += n.vx; n.y += n.vy;
                        n.vx *= 0.85; n.vy *= 0.85;
                    }
                });
            }

            function draw() {
                ctx.save();
                ctx.fillStyle = '#121212';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.translate(canvas.width / 2 + viewOffset.x, canvas.height / 2 + viewOffset.y);
                ctx.scale(scale, scale);

                // --- EDGES RENDERING ---
                edges.forEach(e => {
                    const a = nodes.find(n => n.id === e.source);
                    const b = nodes.find(n => n.id === e.target);
                    if (a && b) {
                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);

                        // Thicker lines for visibility
                        ctx.lineWidth = 2;

                        // --- COLOR LOGIC ---
                        if (e.val < 0) {
                            // NEGATIVE = Bright Red
                            ctx.strokeStyle = 'rgba(255, 0, 85, 0.8)';
                            ctx.shadowColor = '#ff0055';
                            ctx.shadowBlur = 5; // Neon glow effect
                        } else if (e.val > 0 || e.strength > 0.1) {
                            // POSITIVE/CLOSE = Bright Green
                            ctx.strokeStyle = 'rgba(0, 255, 85, 0.8)';
                            ctx.shadowColor = '#00ff55';
                            ctx.shadowBlur = 5;
                        } else {
                            // NEUTRAL/WEAK = Dimmer Grey/Green
                            ctx.strokeStyle = 'rgba(100, 255, 100, 0.3)';
                            ctx.shadowBlur = 0;
                        }

                        ctx.stroke();
                        // Reset shadow for next elements
                        ctx.shadowBlur = 0;

                        if (scale > 1.2) {
                            ctx.fillStyle = '#888'; ctx.font = '10px Arial'; ctx.textAlign = 'center';
                            ctx.fillText(e.label, (a.x + b.x) / 2, (a.y + b.y) / 2);
                        }
                    }
                });

                // --- NODES RENDERING ---
                nodes.forEach(n => {
                    const isHighlight = n.highlight && n.highlight > Date.now();
                    ctx.save();
                    ctx.translate(n.x, n.y);

                    if (isHighlight || n === draggedNode) {
                        ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 20;
                    }

                    ctx.beginPath();
                    ctx.arc(0, 0, NODE_RADIUS, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();

                    if (n.img && n.isLoaded) {
                        ctx.drawImage(n.img, -NODE_RADIUS, -NODE_RADIUS, NODE_RADIUS * 2, NODE_RADIUS * 2);
                    } else {
                        ctx.fillStyle = '#333'; ctx.fill();
                        ctx.fillStyle = '#0f0'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 14px Arial';
                        ctx.fillText(n.data.name ? n.data.name.substring(0, 2).toUpperCase() : '??', 0, 0);
                    }

                    ctx.strokeStyle = isHighlight ? '#ffff00' : '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();

                    if (scale > 0.6 || isHighlight || n === draggedNode) {
                        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = '12px Arial';
                        ctx.fillText(n.data.name, n.x, n.y + NODE_RADIUS + 15);
                    }
                });
                ctx.restore();
            }

            function loop() { update(); draw(); requestAnimationFrame(loop); }
            loop();
        }
    </script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
</body>

</html>