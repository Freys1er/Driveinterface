<!-- No html, head, or body tags -->
<style>
    :root {
        --main-color: #00ff00;
        --bg-color: #000000;
        --border-color: rgba(0, 255, 0, 0.3);
        --glow-color: rgba(0, 255, 0, 0.7);
    }

    .terminal {
        display: flex;
        flex-direction: column;
        height: 100vh;
        padding: 1rem;
        box-sizing: border-box;
    }

    #log {
        flex-grow: 1;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .log-entry {
        margin-bottom: 1rem;
    }

    .prompt::before {
        content: 'C:\\> ';
    }

    .response {
        color: #ccc;
    }

    .response::before {
        content: 'BOT > ';
        color: var(--main-color);
    }

    .error {
        color: #ff4444;
    }

    .input-line {
        display: flex;
        border-top: 1px solid var(--border-color);
        padding-top: 0.5rem;
    }

    .prompt-label {
        margin-right: 0.5rem;
    }

    #commandInput {
        flex-grow: 1;
        background: transparent;
        border: none;
        color: var(--main-color);
        font-family: inherit;
        font-size: 1rem;
    }

    #commandInput:focus {
        outline: none;
    }
</style>

<div class="terminal">
    <div id="log"></div>
    <div class="input-line">
        <span class="prompt-label">C:\></span>
        <input type="text" id="commandInput" autofocus autocomplete="off">
    </div>
</div>

<script>
    // The script is now wrapped in a function that gets called by the main router
    (function (params) {
        const logEl = document.getElementById('log');
        const inputEl = document.getElementById('commandInput');
        let contactContext = null;

        function addLogEntry(text, className) {
            const entry = document.createElement('div');
            entry.className = `log-entry ${className}`;
            entry.textContent = text;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function getContactContext() {
            // Fetch a small sample of contacts to give the AI context
            addLogEntry("Fetching contact context for AI...", "response");
            google.script.run
                .withSuccessHandler(response => {
                    if (response.success && response.data.length > 0) {
                        const sample = response.data.slice(0, 5);
                        contactContext = JSON.stringify(sample);
                        addLogEntry("Context loaded. Ready for commands.", "response");
                    } else {
                        contactContext = "[]";
                        addLogEntry("No contacts found to create context. AI may have limited knowledge.", "error");
                    }
                    inputEl.focus(); // Ensure focus after loading
                })
                .withFailureHandler(err => {
                    addLogEntry(`Failed to load context: ${err.message}`, "error");
                })
                .getAllContacts();
        }
        // Inside bot.html's <script> tag, replace the keydown event listener logic

        inputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && inputEl.value.trim() !== '' && !inputEl.disabled) {
                const command = inputEl.value.trim();
                addLogEntry(command, 'prompt');
                inputEl.value = '';
                handleCommand(command);
            }
        });

        async function handleCommand(command) {
            inputEl.disabled = true;
            addLogEntry("...", "response", true); // Add a placeholder

            try {
                const aiResponseText = await new Promise((resolve, reject) => {
                    google.script.run
                        .withSuccessHandler(res => res.success ? resolve(res.text) : reject(new Error(res.error)))
                        .withFailureHandler(reject)
                        .askGemini(command, contactContext);
                });

                const aiResponseJson = JSON.parse(aiResponseText.replace(/```json|```/g, '').trim());
                updateLastLog(JSON.stringify(aiResponseJson), "response"); // Show the tool call

                // --- TOOL COORDINATOR LOGIC ---
                switch (aiResponseJson.tool) {
                    case "finalResponse":
                        addLogEntry(aiResponseJson.text, "response");
                        break;
                    case "findContactsByName":
                        const findResult = await runTool('findContactsByName', aiResponseJson.query);
                        const resultText = `Found ${findResult.contacts.length} contacts:\n${JSON.stringify(findResult.contacts, null, 2)}`;
                        addLogEntry(resultText, "response");
                        break;
                    case "updateContact":
                        await runTool('updateContact', aiResponseJson.contactData);
                        addLogEntry(`Contact ${aiResponseJson.contactData.id} updated successfully.`, "response");
                        break;
                    case "addContact":
                        const addResult = await runTool('addContact', aiResponseJson.contactData);
                        addLogEntry(`Contact added successfully with new ID: ${addResult.id}`, "response");
                        break;
                    case "performWebSearch":
                        const searchResult = await runTool('performWebSearch', aiResponseJson.query);
                        addLogEntry(searchResult.summary, "response");
                        break;
                    default:
                        addLogEntry("AI returned an unknown tool. Aborting.", "error");
                }

            } catch (err) {
                updateLastLog(`Error: ${err.message}`, "error");
            } finally {
                inputEl.disabled = false;
                inputEl.focus();
            }
        }

        // Helper to run a tool and return a promise
        function runTool(toolName, arg) {
            return new Promise((resolve, reject) => {
                google.script.run
                    .withSuccessHandler(res => res.success ? resolve(res) : reject(new Error(res.error || 'Tool failed')))
                    .withFailureHandler(reject)
                [toolName](arg);
            });
        }

        // Helper to update the "..." placeholder
        function updateLastLog(text, className) {
            const lastEntry = logEl.lastChild;
            if (lastEntry) {
                lastEntry.textContent = text;
                lastEntry.className = `log-entry ${className}`;
            }
        }
        // Initializer for the page fragment
        addLogEntry("ContactOSINT Bot Initializing...", "response");
        getContactContext();
    })
</script>